<!DOCTYPE html>
<html>

<head>
<meta charset="utf-8">
<title>Dart : Libraries : box2d : Shape</title>
</head>

<body>

<header></header>

<h1 id="title">class <a name='Shape::Shape'>Shape</a></h1>

<section id="inheritance">

<section class="supertype">
<h2>Supertype:</h2>
<ul><li>Object</li></ul>
</section>

<section class="subtypes">
<h2>Subtypes:</h2>
<ul>
<li><a href='CircleShape.html#CircleShape::CircleShape'>CircleShape</a></li>
<li><a href='PolygonShape.html#PolygonShape::PolygonShape'>PolygonShape</a></li>
</ul>
</section>

</section>

<section id="summary">

 A shape is used for collision detection. You can create a shape however you
 like. Shapes used for simulation in World are created automatically when
 a Fixture is created.  Shapes may encapsulate a one or more child shapes.
</section>

<section id="fields">
<h2>Fields</h2>
<dl>
<dt>
<span class="field-type"><code><code><a href='num.html#num::num'>num</a></code></code></span>
<span class="field-name"><code><a name='Shape::radius'>radius
</a></code></span>
</dt>
<dd>
</dd>
<dt>
<span class="field-type"><code><code><a href='int.html#int::int'>int</a></code></code></span>
<span class="field-name"><code><a name='Shape::type'>type
</a></code></span>
</dt>
<dd>
</dd>
</dl>
</section>

<section id="constructors">
<h2>Constructors</h2>
<dl>
<dt>
<code><a href='Shape.html#Shape::Shape'>Shape</a>([<code><a href='int.html#int::int'>int</a></code> <a name='Shape::::type'>type</a> = ShapeType.UNKNOWN, <code><a href='num.html#num::num'>num</a></code> <a name='Shape::::radius'>radius</a> = 0])</code>
</dt>
<dd>

 Constructs a new shape of unknown type.
</dd>
</dl>
</section>

<section id="methods">
<h2>Methods</h2>
<dl>
<dt>
<code><code><a href='Shape.html#Shape::Shape'>Shape</a></code> <a name='Shape::clone'>clone</a>()</code></dt>
<dd>
 Returns a clone of this shape. </dd>
<dt>
<code>void <a name='Shape::computeAxisAlignedBox'>computeAxisAlignedBox</a>(<code><a href='AxisAlignedBox.html#AxisAlignedBox::AxisAlignedBox'>AxisAlignedBox</a></code> <a name='Shape::computeAxisAlignedBox::box'>box</a>, <code><a href='Transform.html#Transform::Transform'>Transform</a></code> <a name='Shape::computeAxisAlignedBox::transform'>transform</a>)</code></dt>
<dd>

 Computes the associated axis aligned bounding box for a child shape
 given a transform. Returns through the given out paramater.
</dd>
<dt>
<code>void <a name='Shape::computeMass'>computeMass</a>(<code><a href='MassData.html#MassData::MassData'>MassData</a></code> <a name='Shape::computeMass::massData'>massData</a>, <code><a href='num.html#num::num'>num</a></code> <a name='Shape::computeMass::density'>density</a>)</code></dt>
<dd>

 Computes (and returns through the given out parameter massData) the mass
 properties of this shape using its dimensions and the
 given density. The inertia tensor is computed about the local origin.
</dd>
<dt>
<code><code><a href='bool.html#bool::bool'>bool</a></code> <a name='Shape::testPoint'>testPoint</a>(<code><a href='Transform.html#Transform::Transform'>Transform</a></code> <a name='Shape::testPoint::transform'>transform</a>, <code><a href='Vector.html#Vector::Vector'>Vector</a></code> <a name='Shape::testPoint::point'>point</a>)</code></dt>
<dd>

 Test a point for containment in this shape. This only works for convex
 shapes.
 transform:  the shape world transform.
 point: a point in world coordinates.
</dd>
</dl>
</section>

<footer></footer>

</body></html>
