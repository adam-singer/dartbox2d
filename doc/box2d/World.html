        <!DOCTYPE html>
        <html>
        <head>
                <meta charset="utf-8">
        <title>World Class / box2d Library / Dart Documentation</title>
        <link rel="stylesheet" type="text/css"
            href="../styles.css">
        <link href="http://fonts.googleapis.com/css?family=Open+Sans:400,600,700,800" rel="stylesheet" type="text/css">
        <link rel="shortcut icon" href="../favicon.ico">
        
        </head>
        <body data-library="box2d" data-type="World">
        <div class="page">
        <div class="header">
          <a href="../index.html"><div class="logo"></div></a>
          <a href="../index.html">Dart Documentation</a>
         &rsaquo; <a href="../box2d.html">box2d</a> &rsaquo; <a href="../box2d/World.html">World</a></div>
        <div class="nav">
        
</div>
<div class="content">
        <h2><strong>World</strong>
          Class
        </h2>
        
<div class="doc">
<p>The world class manages all physics entities, dynamic simulation,
and asynchronous queries. The world also contains efficient memory
management facilities.</p>
<p>Author: Daniel Murphy</p>
</div>
<h3>Constructors</h3>
<div class="method"><h4 id="World">
<span class="show-code">Code</span>
new <strong>World</strong>(<a href="../box2d/Vector.html">Vector</a> gravity, <a href="../dart_core/bool.html">bool</a> doSleep, <a href="../box2d/DefaultWorldPool.html">DefaultWorldPool</a> argPool) <a class="anchor-link" href="#World"
              title="Permalink to World.World">#</a></h4>
<div class="doc">
<p>Constructs a world object.</p>
<p>gravity
  the world gravity vector.
doSleep
  improve performance by not simulating inactive bodies.</p>
<pre class="source">
World(Vector gravity, bool doSleep, DefaultWorldPool argPool) :
  _pool = argPool,
  _jointDestructionListener = null,
  _fixtureDestructionListener = null,
  _debugDraw = null,

  _bodyList = null,
  _jointList = null,

  _bodyCount = 0,
  _jointCount = 0,

  _warmStarting = true,
  _continuousPhysics = true,

  _allowSleep = doSleep,
  _gravity = gravity,

  _flags = CLEAR_FORCES,

  _inverseTimestep = 0,

  _contactStacks = new List&lt;List&lt;ContactRegister&gt;&gt;(ShapeType.TYPE_COUNT),

  // Initialize Pool Objects.
  center = new Vector(),
  axis = new Vector(),
  timestep = new TimeStep(),
  cA = new Vector(),
  cB = new Vector(),
  wqwrapper = new WorldQueryWrapper(),
  toiInput = new TimeOfImpactInput(),
  toiOutput = new TimeOfImpactOutput(),
  backup = new Sweep(),
  toiSolver = new TimeOfImpactSolver(),
  contacts = new List&lt;Contact&gt;(Settings.MAX_TIME_OF_IMPACT_CONTACTS),
  island = new Island(),
  stack = new List&lt;Body&gt;(10) {

  _contactManager = new ContactManager(this);

  // Initialize settings.
  for (int i = 0; i &lt; _contactStacks.length; i++) {
    _contactStacks[i] = new List&lt;ContactRegister&gt;(ShapeType.TYPE_COUNT);
  }
  _initializeRegisters();
}
</pre>
</div>
</div>
<h3>Static Fields</h3>
<div class="field"><h4 id="CLEAR_FORCES">
<span class="show-code">Code</span>
final <a href="../dart_core/int.html">int</a>         <strong>CLEAR_FORCES</strong> <a class="anchor-link"
            href="#CLEAR_FORCES"
            title="Permalink to World.CLEAR_FORCES">#</a>
        </h4>
        <div class="doc">

<pre class="source">
static final int CLEAR_FORCES = 0x0004;
</pre>
</div>
</div>
<div class="field"><h4 id="LOCKED">
<span class="show-code">Code</span>
final <a href="../dart_core/int.html">int</a>         <strong>LOCKED</strong> <a class="anchor-link"
            href="#LOCKED"
            title="Permalink to World.LOCKED">#</a>
        </h4>
        <div class="doc">

<pre class="source">
static final int LOCKED = 0x0002;
</pre>
</div>
</div>
<div class="field"><h4 id="NEW_FIXTURE">
<span class="show-code">Code</span>
final <a href="../dart_core/int.html">int</a>         <strong>NEW_FIXTURE</strong> <a class="anchor-link"
            href="#NEW_FIXTURE"
            title="Permalink to World.NEW_FIXTURE">#</a>
        </h4>
        <div class="doc">

<pre class="source">
static final int NEW_FIXTURE = 0x0001;
</pre>
</div>
</div>
<div class="field"><h4 id="WORLD_POOL_CONTAINER_SIZE">
<span class="show-code">Code</span>
final <a href="../dart_core/int.html">int</a>         <strong>WORLD_POOL_CONTAINER_SIZE</strong> <a class="anchor-link"
            href="#WORLD_POOL_CONTAINER_SIZE"
            title="Permalink to World.WORLD_POOL_CONTAINER_SIZE">#</a>
        </h4>
        <div class="doc">

<pre class="source">
static final int WORLD_POOL_CONTAINER_SIZE = 10;
</pre>
</div>
</div>
<div class="field"><h4 id="WORLD_POOL_SIZE">
<span class="show-code">Code</span>
final <a href="../dart_core/int.html">int</a>         <strong>WORLD_POOL_SIZE</strong> <a class="anchor-link"
            href="#WORLD_POOL_SIZE"
            title="Permalink to World.WORLD_POOL_SIZE">#</a>
        </h4>
        <div class="doc">

<pre class="source">
static final int WORLD_POOL_SIZE = 100;
</pre>
</div>
</div>
<h3>Methods</h3>
<div class="method"><h4 id="get:autoClearForces">
<span class="show-code">Code</span>
<a href="../dart_core/bool.html">bool</a> <strong>get autoClearForces</strong>() <a class="anchor-link" href="#get:autoClearForces"
              title="Permalink to World.get autoClearForces">#</a></h4>
<div class="doc">
<p>Get the flag that controls automatic clearing of forces after each time
step.</p>
<pre class="source">
bool get autoClearForces() {
  return (_flags &amp; CLEAR_FORCES) == CLEAR_FORCES;
}
</pre>
</div>
</div>
<div class="method"><h4 id="set:autoClearForces">
<span class="show-code">Code</span>
<a href="../dart_core/void.html">void</a> <strong>set autoClearForces</strong>(<a href="../dart_core/bool.html">bool</a> flag) <a class="anchor-link" href="#set:autoClearForces"
              title="Permalink to World.set autoClearForces">#</a></h4>
<div class="doc">
<p>Set flag to control automatic clearing of forces after each time step.</p>
<pre class="source">
void set autoClearForces(bool flag) {
  if (flag) {
    _flags |= CLEAR_FORCES;
  } else {
    _flags &amp;= ~CLEAR_FORCES;
  }
}
</pre>
</div>
</div>
<div class="method"><h4 id="clearForces">
<span class="show-code">Code</span>
<a href="../dart_core/void.html">void</a> <strong>clearForces</strong>() <a class="anchor-link" href="#clearForces"
              title="Permalink to World.clearForces">#</a></h4>
<div class="doc">
<p>Call this after you are done with time steps to clear the forces.
You normally call this after each call to Step, unless you are
performing sub-steps. By default, forces will be automatically cleared,
so you don't need to call this function.</p>
<p>see setAutoClearForces</p>
<pre class="source">
void clearForces() {
  for (Body body = _bodyList; body != null; body = body.next) {
    body._force.setZero();
    body._torque = 0.0;
  }
}
</pre>
</div>
</div>
<div class="method"><h4 id="get:contactCount">
<span class="show-code">Code</span>
<a href="../dart_core/int.html">int</a> <strong>get contactCount</strong>() <a class="anchor-link" href="#get:contactCount"
              title="Permalink to World.get contactCount">#</a></h4>
<div class="doc">
<p>Get the number of contacts (each may have 0 or more contact points).</p>
<pre class="source">
int get contactCount() {
  return _contactManager.contactCount;
}
</pre>
</div>
</div>
<div class="method"><h4 id="set:contactFilter">
<span class="show-code">Code</span>
<a href="../dart_core/void.html">void</a> <strong>set contactFilter</strong>(<a href="../box2d/ContactFilter.html">ContactFilter</a> filter) <a class="anchor-link" href="#set:contactFilter"
              title="Permalink to World.set contactFilter">#</a></h4>
<div class="doc">
<p>Register a contact filter to provide specific control over collision.
Otherwise the default filter is used (_defaultFilter). The listener is
owned by you and must remain in scope.</p>
<pre class="source">
void set contactFilter(ContactFilter filter) {
  _contactManager.contactFilter = filter;
}
</pre>
</div>
</div>
<div class="method"><h4 id="get:contactList">
<span class="show-code">Code</span>
<a href="../box2d/Contact.html">Contact</a> <strong>get contactList</strong>() <a class="anchor-link" href="#get:contactList"
              title="Permalink to World.get contactList">#</a></h4>
<div class="doc">
<p>Get the world contact list. With the returned contact, use Contact.getNext
to get the next contact in the world list. A null contact indicates the
end of the list.</p>
<p>return the head of the world contact list.
warning contacts are</p>
<pre class="source">
Contact get contactList() {
  return _contactManager.contactList;
}
</pre>
</div>
</div>
<div class="method"><h4 id="get:contactListener">
<span class="show-code">Code</span>
<a href="../box2d/ContactListener.html">ContactListener</a> <strong>get contactListener</strong>() <a class="anchor-link" href="#get:contactListener"
              title="Permalink to World.get contactListener">#</a></h4>
<div class="doc">

<pre class="source">
ContactListener get contactListener() {
  return _contactManager.contactListener;
}
</pre>
</div>
</div>
<div class="method"><h4 id="set:contactListener">
<span class="show-code">Code</span>
<a href="../dart_core/void.html">void</a> <strong>set contactListener</strong>(<a href="../box2d/ContactListener.html">ContactListener</a> listener) <a class="anchor-link" href="#set:contactListener"
              title="Permalink to World.set contactListener">#</a></h4>
<div class="doc">
<p>Register a contact event listener. The listener is owned by you and must
remain in scope.</p>
<pre class="source">
void set contactListener(ContactListener listener) {
  _contactManager.contactListener = listener;
}
</pre>
</div>
</div>
<div class="method"><h4 id="createBody">
<span class="show-code">Code</span>
<a href="../box2d/Body.html">Body</a> <strong>createBody</strong>(<a href="../box2d/BodyDef.html">BodyDef</a> def) <a class="anchor-link" href="#createBody"
              title="Permalink to World.createBody">#</a></h4>
<div class="doc">
<p>Create a rigid body given a definition. No reference to the definition
is retained.</p>
<pre class="source">
Body createBody(BodyDef def) {
  assert (locked == false);
  if (locked) {
    return null;
  }
  Body b = new Body(def, this);

  // add to world doubly linked list
  b.prev = null;
  b.next = _bodyList;
  if (_bodyList != null) {
    _bodyList.prev = b;
  }
  _bodyList = b;
  ++_bodyCount;

  return b;
}
</pre>
</div>
</div>
<div class="method"><h4 id="createJoint">
<span class="show-code">Code</span>
<a href="../box2d/Joint.html">Joint</a> <strong>createJoint</strong>(<a href="../box2d/JointDef.html">JointDef</a> def) <a class="anchor-link" href="#createJoint"
              title="Permalink to World.createJoint">#</a></h4>
<div class="doc">
<p>Create a joint to constrain bodies together. No reference to the definition
is retained. This may cause the connected bodies to cease colliding.</p>
<p>Warning: This function is locked during callbacks.</p>
<pre class="source">
Joint createJoint(JointDef def) {
  assert (locked == false);
  if (locked) {
    return null;
  }

  Joint j = new Joint.create(this, def);

  // Connect to the world list.
  j._prev = null;
  j._next = _jointList;
  if (_jointList != null) _jointList._prev = j;
  _jointList = j;
  ++_jointCount;

  // Connect to the bodies' doubly linked lists.
  j.edgeA.joint = j;
  j.edgeA.other = j.bodyB;
  j.edgeA.prev = null;
  j.edgeA.next = j.bodyA.jointList;
  if (j.bodyA.jointList != null) {
    j.bodyA.jointList.prev = j.edgeA;
  }
  j.bodyA.jointList = j.edgeA;

  j.edgeB.joint = j;
  j.edgeB.other = j.bodyA;
  j.edgeB.prev = null;
  j.edgeB.next = j.bodyB.jointList;
  if (j.bodyB.jointList != null) {
    j.bodyB.jointList.prev = j.edgeB;
  }
  j.bodyB.jointList = j.edgeB;

  Body bodyA = def.bodyA;
  Body bodyB = def.bodyB;

  // If the joint prevents collisions, then flag any contacts for filtering.
  if (def.collideConnected == false) {
    ContactEdge edge = bodyB.contactList;
    while (edge != null) {
      if (edge.other == bodyA) {
        // Flag the contact for filtering at the next time step (where either
        // body is awake).
        edge.contact.flagForFiltering();
      }

      edge = edge.next;
    }
  }

  // Note: creating a joint doesn't wake the bodies.

  return j;
}
</pre>
</div>
</div>
<div class="method"><h4 id="set:debugDraw">
<span class="show-code">Code</span>
<a href="../dart_core/void.html">void</a> <strong>set debugDraw</strong>(<a href="../box2d/DebugDraw.html">DebugDraw</a> debugDraw) <a class="anchor-link" href="#set:debugDraw"
              title="Permalink to World.set debugDraw">#</a></h4>
<div class="doc">
<p>Register a routine for debug drawing. The debug draw functions are called
inside with World.DrawDebugData method. The debug draw object is owned
by you and must remain in scope.</p>
<pre class="source">
void set debugDraw(DebugDraw debugDraw) {
  _debugDraw = debugDraw;
}
</pre>
</div>
</div>
<div class="method"><h4 id="destroyBody">
<span class="show-code">Code</span>
<a href="../dart_core/void.html">void</a> <strong>destroyBody</strong>(<a href="../box2d/Body.html">Body</a> body) <a class="anchor-link" href="#destroyBody"
              title="Permalink to World.destroyBody">#</a></h4>
<div class="doc">
<p>Destroy a rigid body given a definition. No reference to the definition
is retained. This function is locked during callbacks.</p>
<p>warning: This automatically deletes all associated shapes.
warning: This function is locked during callbacks.</p>
<pre class="source">
void destroyBody(Body body) {
  assert (_bodyCount &gt; 0);
  assert (locked == false);
  if (locked) {
    return;
  }

  // Delete the attached joints.
  JointEdge je = body.jointList;
  while (je != null) {
    JointEdge je0 = je;
    je = je.next;
    if (_jointDestructionListener != null) {
      _jointDestructionListener(je0.joint);
    }

    destroyJoint(je0.joint);
  }
  body.jointList = null;

  // Delete the attached contacts.
  ContactEdge ce = body.contactList;
  while (ce != null) {
    ContactEdge ce0 = ce;
    ce = ce.next;
    _contactManager.destroy(ce0.contact);
  }
  body.contactList = null;

  Fixture f = body.fixtureList;
  while (f != null) {
    Fixture f0 = f;
    f = f.next;

    if (_fixtureDestructionListener != null) {
      _fixtureDestructionListener(f0);
    }

    f0.destroyProxy(_contactManager.broadPhase);
    f0.destroy();
    // TODO djm recycle fixtures (here or in that destroy method)
  }
  body.fixtureList = null;
  body.fixtureCount = 0;

  // Remove world body list.
  if (body.prev != null) {
    body.prev.next = body.next;
  }

  if (body.next != null) {
    body.next.prev = body.prev;
  }

  if (body == _bodyList) {
    _bodyList = body.next;
  }

  --_bodyCount;
}
</pre>
</div>
</div>
<div class="method"><h4 id="destroyJoint">
<span class="show-code">Code</span>
<a href="../dart_core/void.html">void</a> <strong>destroyJoint</strong>(<a href="../box2d/Joint.html">Joint</a> joint) <a class="anchor-link" href="#destroyJoint"
              title="Permalink to World.destroyJoint">#</a></h4>
<div class="doc">
<p>Destroy a joint. This may cause the connected bodies to begin colliding.</p>
<p>Warning: This function is locked during callbacks.</p>
<pre class="source">
void destroyJoint(Joint joint) {
  assert (locked == false);
  if (locked) {
    return;
  }

  bool collideConnected = joint.collideConnected;

  // Remove from the doubly linked list.
  if (joint._prev != null) joint._prev._next = joint._next;

  if (joint._next != null) joint._next._prev = joint._prev;

  if (joint == _jointList) _jointList = joint._next;

  // Disconnect from island graph.
  Body bodyA = joint.bodyA;
  Body bodyB = joint.bodyB;

  // Wake up connected bodies.
  bodyA.awake = true;
  bodyB.awake = true;

  // Remove from body 1.
  if (joint.edgeA.prev != null) {
    joint.edgeA.prev.next = joint.edgeA.next;
  }

  if (joint.edgeA.next != null) {
    joint.edgeA.next.prev = joint.edgeA.prev;
  }

  if (joint.edgeA == bodyA.jointList) {
    bodyA.jointList = joint.edgeA.next;
  }

  joint.edgeA.prev = null;
  joint.edgeA.next = null;

  // Remove from body 2
  if (joint.edgeB.prev != null) {
    joint.edgeB.prev.next = joint.edgeB.next;
  }

  if (joint.edgeB.next != null) {
    joint.edgeB.next.prev = joint.edgeB.prev;
  }

  if (joint.edgeB == bodyB.jointList) {
    bodyB.jointList = joint.edgeB.next;
  }

  joint.edgeB.prev = null;
  joint.edgeB.next = null;

  Joint.destroy(joint);

  assert (_jointCount &gt; 0);
  --_jointCount;

  // If the joint prevents collisions, then flag any contacts for filtering.
  if (collideConnected == false) {
    ContactEdge edge = bodyB.contactList;
    while (edge != null) {
      if (edge.other == bodyA) {
        // Flag the contact for filtering at the next time step (where either
        // body is awake).
        edge.contact.flagForFiltering();
      }

      edge = edge.next;
    }
  }
}
</pre>
</div>
</div>
<div class="method"><h4 id="drawDebugData">
<span class="show-code">Code</span>
<a href="../dart_core/void.html">void</a> <strong>drawDebugData</strong>() <a class="anchor-link" href="#drawDebugData"
              title="Permalink to World.drawDebugData">#</a></h4>
<div class="doc">
<p>Call this to draw shapes and other debug draw data.</p>
<pre class="source">
void drawDebugData() {
  if (_debugDraw == null) {
    return;
  }

  final int drawFlags = _debugDraw.drawFlags;

  if ((drawFlags &amp; DebugDraw.e_shapeBit) == DebugDraw.e_shapeBit) {
    Transform xf = new Transform();
    Color3 color = new Color3();
    for (Body b = _bodyList; b != null; b = b.next) {
      xf.setFrom(b.originTransform);
      for (Fixture f = b.fixtureList; f != null; f = f.next) {
        if (b.active == false) {
          color.setFromRGB(0.5, 0.5, 0.3);
          drawShape(f, xf, color);
        } else if (b.type == BodyType.STATIC) {
          color.setFromRGB(0.5, 0.9, 0.3);
          drawShape(f, xf, color);
        } else if (b.type == BodyType.KINEMATIC) {
          color.setFromRGB(0.5, 0.5, 0.9);
          drawShape(f, xf, color);
        } else if (b.awake == false) {
          color.setFromRGB(0.9, 0.9, 0.9);
          drawShape(f, xf, color);
        } else {
          color.setFromRGB(0.9, 0.7, 0.7);
          drawShape(f, xf, color);
        }
      }
    }
  }

  if ((drawFlags &amp; DebugDraw.e_jointBit) == DebugDraw.e_jointBit) {
    for (Joint j = _jointList; j != null; j = j._next)
      drawJoint(j);
  }

  if ((drawFlags &amp; DebugDraw.e_pairBit) == DebugDraw.e_pairBit) {
    Color3 color = new Color3.fromRGB(0.3, 0.9, 0.9);
    for (Contact c = _contactManager.contactList; c != null; c = c.next) {
      Fixture fixtureA = c.fixtureA;
      Fixture fixtureB = c.fixtureB;

      cA.setFrom(fixtureA.box.center);
      cB.setFrom(fixtureB.box.center);

      _debugDraw.drawSegment(cA, cB, color);
    }
  }

  if ((drawFlags &amp; DebugDraw.e_aabbBit) == DebugDraw.e_aabbBit) {
    Color3 color = new Color3.fromRGB(0.9, 0.3, 0.9);

    for (Body b = _bodyList; b != null; b = b.next) {
      if (!b.active) {
        continue;
      }

      for (Fixture f = b.fixtureList; f != null; f = f.next) {
        AxisAlignedBox aabb = f.proxy.box;

        List&lt;Vector&gt; vs = new List&lt;Vector&gt;(4);
        for (int i = 0; i &lt; vs.length; i++) {
          vs[i] = new Vector();
        }

        vs[0].setCoords(aabb.lowerBound.x, aabb.lowerBound.y);
        vs[1].setCoords(aabb.upperBound.x, aabb.lowerBound.y);
        vs[2].setCoords(aabb.upperBound.x, aabb.upperBound.y);
        vs[3].setCoords(aabb.lowerBound.x, aabb.upperBound.y);

        if (0 !== (drawFlags &amp; DebugDraw.e_lineDrawingBit)) {
          _debugDraw.drawPolygon(vs, 4, color);
        } else {
          _debugDraw.drawSolidPolygon(vs, 4, color);
        }
      }
    }
  }

  if ((drawFlags &amp; DebugDraw.e_centerOfMassBit) ==
      DebugDraw.e_centerOfMassBit) {
    Transform xf = new Transform();
    final Color3 color = new Color3.fromRGB(1, 0, 0);
    for (Body b = _bodyList; b != null; b = b.next) {
      xf.setFrom(b.originTransform);
      xf.position.setFrom(b.worldCenter);
      _debugDraw.drawTransform(xf, color);
    }
  }
}
</pre>
</div>
</div>
<div class="method"><h4 id="drawJoint">
<span class="show-code">Code</span>
<a href="../dart_core/void.html">void</a> <strong>drawJoint</strong>(<a href="../box2d/Joint.html">Joint</a> joint) <a class="anchor-link" href="#drawJoint"
              title="Permalink to World.drawJoint">#</a></h4>
<div class="doc">
<p>Draws a joint for debugging purposes.</p>
<pre class="source">
void drawJoint(Joint joint) {
  Body bodyA = joint.bodyA;
  Body bodyB = joint.bodyB;
  Transform xf1 = bodyA.originTransform;
  Transform xf2 = bodyB.originTransform;
  Vector x1 = new Vector.copy(xf1.position);
  Vector x2 = new Vector.copy(xf2.position);
  Vector p1 = new Vector();
  Vector p2 = new Vector();
  joint.getAnchorA(p1);
  joint.getAnchorB(p2);

  // Set the drawing color.
  Color3 color = new Color3.fromRGB(0.5, 0.3, 0.3);

  switch (joint.type) {
    case JointType.DISTANCE :
      _debugDraw.drawSegment(p1, p2, color);
      break;

    case JointType.PULLEY :
      throw new NotImplementedException();
      //Vector s1 = pulley.getGroundAnchorA();
      //Vector s2 = pulley.getGroundAnchorB();
      //_debugDraw.drawSegment(s1, p1, color);
      //_debugDraw.drawSegment(s2, p2, color);
      //_debugDraw.drawSegment(s1, s2, color);
      //break;

    case JointType.FRICTION:
      _debugDraw.drawSegment(x1, x2, color);
      break;

    case JointType.CONSTANT_VOLUME :
      // Nothing to see here.
    case JointType.MOUSE :
      // Don't draw anything for mouse. Already have cursor!
      break;
    default :
      Vector p1t = new Vector.copy(p1); // copies since drawSegment modifies
      Vector p2t = new Vector.copy(p2);
      _debugDraw.drawSegment(x1, p1, color);
      _debugDraw.drawSegment(p1t, p2, color);
      _debugDraw.drawSegment(x2, p2t, color);
  }
}
</pre>
</div>
</div>
<div class="method"><h4 id="drawShape">
<span class="show-code">Code</span>
<a href="../dart_core/void.html">void</a> <strong>drawShape</strong>(<a href="../box2d/Fixture.html">Fixture</a> fixture, <a href="../box2d/Transform.html">Transform</a> xf, <a href="../box2d/Color3.html">Color3</a> color) <a class="anchor-link" href="#drawShape"
              title="Permalink to World.drawShape">#</a></h4>
<div class="doc">

<pre class="source">
void drawShape(Fixture fixture, Transform xf, Color3 color) {
  switch (fixture.type) {
    case ShapeType.CIRCLE :
      final CircleShape circle = fixture.shape;

      // Vector center = Mul(xf, circle.p);
      Transform.mulToOut(xf, circle.position, center);
      num radius = circle.radius;
      axis.setFrom(xf.rotation.col1);

      if (0 !== (_debugDraw.drawFlags &amp; DebugDraw.e_lineDrawingBit)) {
        _debugDraw.drawCircle(center, radius, color, axis);
      } else {
        _debugDraw.drawSolidCircle(center, radius, color, axis);
      }
      break;

    case ShapeType.POLYGON:
     final PolygonShape poly = fixture.shape;
     int vertexCount = poly.vertexCount;
     assert (vertexCount &lt;= Settings.MAX_POLYGON_VERTICES);
     List&lt;Vector&gt; vertices =
         new List&lt;Vector&gt;(vertexCount);
     for (int i = 0; i &lt; vertexCount; i++) {
       vertices[i] = new Vector();
     }

     for (int i = 0; i &lt; vertexCount; ++i) {
       assert(poly.vertices[i] != null);
       assert(vertices[i] != null);
       Transform.mulToOut(xf, poly.vertices[i], vertices[i]);
     }

     if (0 !== (_debugDraw.drawFlags &amp; DebugDraw.e_lineDrawingBit)) {
       _debugDraw.drawPolygon(vertices, vertexCount, color);
     } else {
       _debugDraw.drawSolidPolygon(vertices, vertexCount, color);
     }
  }
}
</pre>
</div>
</div>
<div class="method"><h4 id="get:jointCount">
<span class="show-code">Code</span>
<a href="../dart_core/int.html">int</a> <strong>get jointCount</strong>() <a class="anchor-link" href="#get:jointCount"
              title="Permalink to World.get jointCount">#</a></h4>
<div class="doc">

<pre class="source">
int get jointCount() {
  return _jointCount;
}
</pre>
</div>
</div>
<div class="method"><h4 id="get:jointList">
<span class="show-code">Code</span>
<a href="../box2d/Joint.html">Joint</a> <strong>get jointList</strong>() <a class="anchor-link" href="#get:jointList"
              title="Permalink to World.get jointList">#</a></h4>
<div class="doc">

<pre class="source">
Joint get jointList() {
  return _jointList;
}
</pre>
</div>
</div>
<div class="method"><h4 id="get:locked">
<span class="show-code">Code</span>
<a href="../dart_core/bool.html">bool</a> <strong>get locked</strong>() <a class="anchor-link" href="#get:locked"
              title="Permalink to World.get locked">#</a></h4>
<div class="doc">
<p>Is the world locked (in the middle of a time step).</p>
<pre class="source">
bool get locked() {
  return (_flags &amp; LOCKED) == LOCKED;
}
</pre>
</div>
</div>
<div class="method"><h4 id="popContact">
<span class="show-code">Code</span>
<a href="../box2d/Contact.html">Contact</a> <strong>popContact</strong>(<a href="../box2d/Fixture.html">Fixture</a> fixtureA, <a href="../box2d/Fixture.html">Fixture</a> fixtureB) <a class="anchor-link" href="#popContact"
              title="Permalink to World.popContact">#</a></h4>
<div class="doc">

<pre class="source">
Contact popContact(Fixture fixtureA, Fixture fixtureB) {
  int type1 = fixtureA.type;
  int type2 = fixtureB.type;

  ContactRegister reg = _contactStacks[type1][type2];
  Queue&lt;Contact&gt; creator = reg.creator;
  if (creator != null) {

    // Ensure that the creator isn't depleted of contact stacks.
    if (creator.isEmpty()) {
      creator = _getFreshContactStack(type1, type2);
    }

    if (reg.primary) {
      Contact c = creator.removeFirst();
      c.init(fixtureA, fixtureB);
      return c;
    } else {
      Contact c = creator.removeFirst();
      c.init(fixtureB, fixtureA);
      return c;
    }
  } else {
    return null;
  }
}
</pre>
</div>
</div>
<div class="method"><h4 id="get:proxyCount">
<span class="show-code">Code</span>
<a href="../dart_core/int.html">int</a> <strong>get proxyCount</strong>() <a class="anchor-link" href="#get:proxyCount"
              title="Permalink to World.get proxyCount">#</a></h4>
<div class="doc">
<p>Get the number of broad-phase proxies.</p>
<pre class="source">
int get proxyCount() {
  return _contactManager.broadPhase.proxyCount;
}
</pre>
</div>
</div>
<div class="method"><h4 id="pushContact">
<span class="show-code">Code</span>
<a href="../dart_core/void.html">void</a> <strong>pushContact</strong>(<a href="../box2d/Contact.html">Contact</a> contact) <a class="anchor-link" href="#pushContact"
              title="Permalink to World.pushContact">#</a></h4>
<div class="doc">

<pre class="source">
void pushContact(Contact contact) {
  if (contact.manifold.pointCount &gt; 0) {
    contact.fixtureA.body.awake = true;
    contact.fixtureB.body.awake = true;
  }

  int type1 = contact.fixtureA.type;
  int type2 = contact.fixtureB.type;

  Queue&lt;Contact&gt; creator = _contactStacks[type1][type2].creator;
  creator.addFirst(contact);
}
</pre>
</div>
</div>
<div class="method"><h4 id="queryAABB">
<span class="show-code">Code</span>
<a href="../dart_core/void.html">void</a> <strong>queryAABB</strong>(<a href="../box2d/QueryCallback.html">QueryCallback</a> callback, <a href="../box2d/AxisAlignedBox.html">AxisAlignedBox</a> aabb) <a class="anchor-link" href="#queryAABB"
              title="Permalink to World.queryAABB">#</a></h4>
<div class="doc">
<p>Query the world for all fixtures that potentially overlap the
provided AABB.</p>
<p>param callback
  a user implemented callback class.
param aabb
  the query box.</p>
<pre class="source">
void queryAABB(QueryCallback callback, AxisAlignedBox aabb) {
  wqwrapper.broadPhase = _contactManager.broadPhase;
  wqwrapper.callback = callback;
  _contactManager.broadPhase.query(wqwrapper, aabb);
}
</pre>
</div>
</div>
<div class="method"><h4 id="solve">
<span class="show-code">Code</span>
<a href="../dart_core/void.html">void</a> <strong>solve</strong>(<a href="../box2d/TimeStep.html">TimeStep</a> timeStep) <a class="anchor-link" href="#solve"
              title="Permalink to World.solve">#</a></h4>
<div class="doc">

<pre class="source">
void solve(TimeStep timeStep) {
  // Size the  for the worst case.
  island.init(_bodyCount, _contactManager.contactCount, _jointCount,
      _contactManager.contactListener);

  // Clear all the island flags.
  for (Body b = _bodyList; b != null; b = b.next) {
    b.flags &amp;= ~Body.ISLAND_FLAG;
  }
  for (Contact c = _contactManager.contactList; c != null; c = c.next) {
    c.flags &amp;= ~Contact.ISLAND_FLAG;
  }
  for (Joint j = jointList; j != null; j = j._next) {
    j.islandFlag = false;
  }

  // Build and simulate all awake islands.
  int stackSize = _bodyCount;
  if (stack.length &lt; stackSize) {
    stack = new List&lt;Body&gt;(stackSize);
  }

  for (Body seed = _bodyList; seed != null; seed = seed.next) {
    if ((seed.flags &amp; Body.ISLAND_FLAG) == Body.ISLAND_FLAG) {
      continue;
    }

    if (seed.awake == false || seed.active == false) {
      continue;
    }

    // The seed can be dynamic or kinematic.
    if (seed.type == BodyType.STATIC) {
      continue;
    }

    // Reset island and stack.
    island.clear();
    int stackCount = 0;
    stack[stackCount++] = seed;
    seed.flags |= Body.ISLAND_FLAG;

    // Perform a depth first search (DFS) on the constraint graph.
    while (stackCount &gt; 0) {
      // Grab the next body off the stack and add it to the island.
      Body b = stack[--stackCount];
      assert (b.active);
      island.addBody(b);

      // Make sure the body is awake.
      b.awake = true;

      // To keep islands as small as possible, we don't
      // propagate islands across static bodies.
      if (b.type == BodyType.STATIC) {
        continue;
      }

      // Search all contacts connected to this body.
      for (ContactEdge ce = b.contactList; ce != null; ce = ce.next) {
        Contact contact = ce.contact;

        // Has this contact already been added to an island?
        if ((contact.flags &amp; Contact.ISLAND_FLAG) == Contact.ISLAND_FLAG) {
          continue;
        }

        // Is this contact solid and touching?
        if (contact.enabled == false || contact.touching == false) {
          continue;
        }

        // Skip sensors.
        bool sensorA = contact.fixtureA.isSensor;
        bool sensorB = contact.fixtureB.isSensor;
        if (sensorA || sensorB) {
          continue;
        }

        island.addContact(contact);
        contact.flags |= Contact.ISLAND_FLAG;

        Body other = ce.other;

        // Was the other body already added to this island?
        if ((other.flags &amp; Body.ISLAND_FLAG) == Body.ISLAND_FLAG) {
          continue;
        }

        assert (stackCount &lt; stackSize);
        stack[stackCount++] = other;
        other.flags |= Body.ISLAND_FLAG;
      }

      // Search all joints connect to this body.
      for (JointEdge je = b.jointList; je != null; je = je.next) {
        if (je.joint.islandFlag == true) {
          continue;
        }

        Body other = je.other;

        // Don't simulate joints connected to inactive bodies.
        if (other.active == false) {
          continue;
        }

        island.addJoint(je.joint);
        je.joint.islandFlag = true;

        if (((other.flags &amp; Body.ISLAND_FLAG) == Body.ISLAND_FLAG)) {
          continue;
        }

        assert (stackCount &lt; stackSize);
        stack[stackCount++] = other;
        other.flags |= Body.ISLAND_FLAG;
      }
    }

    island.solve(timeStep, _gravity, _allowSleep);

    // Post solve cleanup.
    for (int i = 0; i &lt; island.bodyCount; ++i) {
      // Allow static bodies to participate in other islands.
      Body b = island.bodies[i];
      if (b.type == BodyType.STATIC) {
        b.flags &amp;= ~Body.ISLAND_FLAG;
      }
    }
  }

  // Synchronize fixtures, check for out of range bodies.
  for (Body b = _bodyList; b != null; b = b.next) {
    // If a body was not in an island then it did not move.
    if ((b.flags &amp; Body.ISLAND_FLAG) == 0) {
      continue;
    }

    if (b.type == BodyType.STATIC) {
      continue;
    }

    // Update fixtures (for broad-phase).
    b.synchronizeFixtures();
  }

  // Look for new contacts.
  _contactManager.findNewContacts();
}
</pre>
</div>
</div>
<div class="method"><h4 id="solveTimeOfImpact">
<span class="show-code">Code</span>
<a href="../dart_core/void.html">void</a> <strong>solveTimeOfImpact</strong>() <a class="anchor-link" href="#solveTimeOfImpact"
              title="Permalink to World.solveTimeOfImpact">#</a></h4>
<div class="doc">

<pre class="source">
void solveTimeOfImpact() {
  // Prepare all contacts.
  for (Contact c = _contactManager.contactList; c != null; c = c.next) {
    // Enable the contact
    c.flags |= Contact.ENABLED_FLAG;

    // Set the number of TimeOfImpact events for this contact to zero.
    c.toiCount = 0;
  }

  // Initialize the TimeOfImpact flag.
  for (Body body = _bodyList; body != null; body = body.next) {
    // Kinematic, and static bodies will not be affected by the TimeOfImpact
    // event.  If a body was not in an island then it did not move.
    if ((body.flags &amp; Body.ISLAND_FLAG) == 0 || body.type
        == BodyType.KINEMATIC
        || body.type == BodyType.STATIC) {
      body.flags |= Body.TO_I_FLAG;
    }
    else {
      body.flags &amp;= ~Body.TO_I_FLAG;
    }
  }

  // Collide non-bullets.
  for (Body body = _bodyList; body != null; body = body.next) {
    if ((body.flags &amp; Body.TO_I_FLAG) == Body.TO_I_FLAG) {
      continue;
    }

    if (body.bullet == true) {
      continue;
    }

    solveTimeOfImpactGivenBody(body);

    body.flags |= Body.TO_I_FLAG;
  }

  // Collide bullets.
  for (Body body = _bodyList; body != null; body = body.next) {
    if ((body.flags &amp; Body.TO_I_FLAG) == Body.TO_I_FLAG) {
      continue;
    }

    if (body.bullet == false) {
      continue;
    }

    solveTimeOfImpactGivenBody(body);

    body.flags |= Body.TO_I_FLAG;
  }
}
</pre>
</div>
</div>
<div class="method"><h4 id="solveTimeOfImpactGivenBody">
<span class="show-code">Code</span>
<a href="../dart_core/void.html">void</a> <strong>solveTimeOfImpactGivenBody</strong>(<a href="../box2d/Body.html">Body</a> body) <a class="anchor-link" href="#solveTimeOfImpactGivenBody"
              title="Permalink to World.solveTimeOfImpactGivenBody">#</a></h4>
<div class="doc">

<pre class="source">
void solveTimeOfImpactGivenBody(Body body) {
  // Find the minimum contact.
  Contact toiContact = null;
  num toi = 1.0;
  Body toiOther = null;
  bool found;
  int count;
  int iter = 0;

  bool bullet = body.bullet;

  // Iterate until all contacts agree on the minimum TimeOfImpact. We have
  // to iterate because the TimeOfImpact algorithm may skip some intermediate
  // collisions when objects rotate through each other.
  do {
    count = 0;
    found = false;
    for (ContactEdge ce = body.contactList; ce != null; ce = ce.next) {
      if (ce.contact == toiContact) {
        continue;
      }

      Body other = ce.other;
      int type = other.type;

      // Only bullets perform TimeOfImpact with dynamic bodies.
      if (bullet == true) {
        // Bullets only perform TimeOfImpact with bodies that have their
        // TimeOfImpact resolved.
        if ((other.flags &amp; Body.TO_I_FLAG) == 0) {
          continue;
        }

        // No repeated hits on non-static bodies
        if (type != BodyType.STATIC &amp;&amp; (ce.contact.flags &amp;
              Contact.BULLET_HIT_FLAG) != 0) {
          continue;
        }
      } else if (type == BodyType.DYNAMIC) {
        continue;
      }

      // Check for a disabled contact.
      Contact contact = ce.contact;
      if (contact.enabled == false) {
        continue;
      }

      // Prevent infinite looping.
      if (contact.toiCount &gt; 10) {
        continue;
      }

      Fixture fixtureA = contact.fixtureA;
      Fixture fixtureB = contact.fixtureB;

      // Cull sensors.
      if (fixtureA.isSensor || fixtureB.isSensor) {
        continue;
      }

      Body bodyA = fixtureA.body;
      Body bodyB = fixtureB.body;

      // Compute the time of impact in interval [0, minTimeOfImpact]
      toiInput.proxyA.setFromShape(fixtureA.shape);
      toiInput.proxyB.setFromShape(fixtureB.shape);
      toiInput.sweepA.setFrom(bodyA.sweep);
      toiInput.sweepB.setFrom(bodyB.sweep);
      toiInput.tMax = toi;

      _pool.timeOfImpact.timeOfImpact(toiOutput, toiInput);

      if (toiOutput.state == TimeOfImpactOutputState.TOUCHING &amp;&amp;
          toiOutput.t &lt; toi) {
        toiContact = contact;
        toi = toiOutput.t;
        toiOther = other;
        found = true;
      }

      ++count;
    }

    ++iter;
  } while (found &amp;&amp; count &gt; 1 &amp;&amp; iter &lt; 50);

  if (toiContact == null) {
    body.advance(1.0);
    return;
  }

  backup.setFrom(body.sweep);
  body.advance(toi);
  toiContact.update(_contactManager.contactListener);
  if (toiContact.enabled == false) {
    // Contact disabled. Backup and recurse.
    body.sweep.setFrom(backup);
    solveTimeOfImpactGivenBody(body);
  }

  ++toiContact.toiCount;

  // Update all the valid contacts on this body and build a contact island.
  if (contacts == null || contacts.length &lt;
      Settings.MAX_TIME_OF_IMPACT_CONTACTS){
    contacts = new List&lt;Contact&gt;(Settings.MAX_TIME_OF_IMPACT_CONTACTS);
  }

  count = 0;
  for (ContactEdge ce = body.contactList; ce != null &amp;&amp; count
      &lt; Settings.MAX_TIME_OF_IMPACT_CONTACTS; ce = ce.next) {
    Body other = ce.other;
    int type = other.type;

    // Only perform correction with static bodies, so the
    // body won't get pushed out of the world.
    if (type == BodyType.DYNAMIC) {
      continue;
    }

    // Check for a disabled contact.
    Contact contact = ce.contact;
    if (contact.enabled == false) {
      continue;
    }

    Fixture fixtureA = contact.fixtureA;
    Fixture fixtureB = contact.fixtureB;

    // Cull sensors.
    if (fixtureA.isSensor || fixtureB.isSensor) {
      continue;
    }

    // The contact likely has some new contact points. The listener
    // gives the user a chance to disable the contact.
    if (contact != toiContact) {
      contact.update(_contactManager.contactListener);
    }

    // Did the user disable the contact?
    if (contact.enabled == false) {
      // Skip this contact.
      continue;
    }

    if (contact.touching == false) {
      continue;
    }

    contacts[count] = contact;
    ++count;
  }

  // Reduce the TimeOfImpact body's overlap with the contact island.
  toiSolver.initialize(contacts, count, body);

  num k_toiBaumgarte = 0.75;
  // bool solved = false;
  for (int i = 0; i &lt; 20; ++i) {
    bool contactsOkay = toiSolver.solve(k_toiBaumgarte);
    if (contactsOkay) {
      // solved = true;
      break;
    }
  }

  if (toiOther.type != BodyType.STATIC) {
    toiContact.flags |= Contact.BULLET_HIT_FLAG;
  }
}
</pre>
</div>
</div>
<div class="method"><h4 id="step">
<span class="show-code">Code</span>
<a href="../dart_core/void.html">void</a> <strong>step</strong>(<a href="../dart_core/num.html">num</a> dt, <a href="../dart_core/int.html">int</a> velocityIterations, <a href="../dart_core/int.html">int</a> positionIterations) <a class="anchor-link" href="#step"
              title="Permalink to World.step">#</a></h4>
<div class="doc">
<p>Take a time step. This performs collision detection, integration,
and constraint solution.</p>
<p>param timeStep
  the amount of time to simulate, this should not vary.
param velocityIterations
  for the velocity constraint solver.
param positionIterations
  for the position constraint solver.</p>
<pre class="source">
void step(num dt, int velocityIterations, int positionIterations) {

  // If new fixtures were added, we need to find the new contacts.
  if ((_flags &amp; NEW_FIXTURE) == NEW_FIXTURE) {
    _contactManager.findNewContacts();
    _flags &amp;= ~NEW_FIXTURE;
  }

  _flags |= LOCKED;

  timestep.dt = dt;
  timestep.velocityIterations = velocityIterations;
  timestep.positionIterations = positionIterations;
  if (dt &gt; 0.0) {
    timestep.inv_dt = 1.0 / dt;
  } else {
    timestep.inv_dt = 0.0;
  }

  timestep.dtRatio = _inverseTimestep * dt;
  timestep.warmStarting = _warmStarting;

  // Update contacts. This is where some contacts are destroyed.
  _contactManager.collide();

  // Integrate velocities, solve velocity constraints, and integrate
  // positions.
  if (timestep.dt &gt; 0.0) {
    solve(timestep);
  }

  // Handle TimeOfImpact events.
  if (_continuousPhysics &amp;&amp; timestep.dt &gt; 0.0) {
    solveTimeOfImpact();
  }

  if (timestep.dt &gt; 0.0) {
    _inverseTimestep = timestep.inv_dt;
  }

  if ((_flags &amp; CLEAR_FORCES) == CLEAR_FORCES) {
    clearForces();
  }

  _flags &amp;= ~LOCKED;
}
</pre>
</div>
</div>
<h3>Fields</h3>
<div class="field"><h4 id="axis">
<span class="show-code">Code</span>
final <a href="../box2d/Vector.html">Vector</a>         <strong>axis</strong> <a class="anchor-link"
            href="#axis"
            title="Permalink to World.axis">#</a>
        </h4>
        <div class="doc">

<pre class="source">
final Vector axis;
</pre>
</div>
</div>
<div class="field"><h4 id="backup">
<span class="show-code">Code</span>
final <a href="../box2d/Sweep.html">Sweep</a>         <strong>backup</strong> <a class="anchor-link"
            href="#backup"
            title="Permalink to World.backup">#</a>
        </h4>
        <div class="doc">

<pre class="source">
final Sweep backup;
</pre>
</div>
</div>
<div class="field"><h4 id="cA">
<span class="show-code">Code</span>
final <a href="../box2d/Vector.html">Vector</a>         <strong>cA</strong> <a class="anchor-link"
            href="#cA"
            title="Permalink to World.cA">#</a>
        </h4>
        <div class="doc">

<pre class="source">
final Vector cA;
</pre>
</div>
</div>
<div class="field"><h4 id="cB">
<span class="show-code">Code</span>
final <a href="../box2d/Vector.html">Vector</a>         <strong>cB</strong> <a class="anchor-link"
            href="#cB"
            title="Permalink to World.cB">#</a>
        </h4>
        <div class="doc">

<pre class="source">
final Vector cB;
</pre>
</div>
</div>
<div class="field"><h4 id="center">
<span class="show-code">Code</span>
final <a href="../box2d/Vector.html">Vector</a>         <strong>center</strong> <a class="anchor-link"
            href="#center"
            title="Permalink to World.center">#</a>
        </h4>
        <div class="doc">
<p>Pooling</p>
<pre class="source">
final Vector center;
</pre>
</div>
</div>
<div class="field"><h4 id="contacts">
<span class="show-code">Code</span>
<a href="../dart_core/List.html">List</a>         <strong>contacts</strong> <a class="anchor-link"
            href="#contacts"
            title="Permalink to World.contacts">#</a>
        </h4>
        <div class="doc">

<pre class="source">
List&lt;Contact&gt; contacts;
</pre>
</div>
</div>
<div class="field"><h4 id="island">
<span class="show-code">Code</span>
final <a href="../box2d/Island.html">Island</a>         <strong>island</strong> <a class="anchor-link"
            href="#island"
            title="Permalink to World.island">#</a>
        </h4>
        <div class="doc">

<pre class="source">
final Island island;
</pre>
</div>
</div>
<div class="field"><h4 id="stack">
<span class="show-code">Code</span>
<a href="../dart_core/List.html">List</a>         <strong>stack</strong> <a class="anchor-link"
            href="#stack"
            title="Permalink to World.stack">#</a>
        </h4>
        <div class="doc">

<pre class="source">
List&lt;Body&gt; stack;
</pre>
</div>
</div>
<div class="field"><h4 id="timestep">
<span class="show-code">Code</span>
final <a href="../box2d/TimeStep.html">TimeStep</a>         <strong>timestep</strong> <a class="anchor-link"
            href="#timestep"
            title="Permalink to World.timestep">#</a>
        </h4>
        <div class="doc">

<pre class="source">
final TimeStep timestep;
</pre>
</div>
</div>
<div class="field"><h4 id="toiInput">
<span class="show-code">Code</span>
final <a href="../box2d/TimeOfImpactInput.html">TimeOfImpactInput</a>         <strong>toiInput</strong> <a class="anchor-link"
            href="#toiInput"
            title="Permalink to World.toiInput">#</a>
        </h4>
        <div class="doc">

<pre class="source">
final TimeOfImpactInput toiInput;
</pre>
</div>
</div>
<div class="field"><h4 id="toiOutput">
<span class="show-code">Code</span>
final <a href="../box2d/TimeOfImpactOutput.html">TimeOfImpactOutput</a>         <strong>toiOutput</strong> <a class="anchor-link"
            href="#toiOutput"
            title="Permalink to World.toiOutput">#</a>
        </h4>
        <div class="doc">

<pre class="source">
final TimeOfImpactOutput toiOutput;
</pre>
</div>
</div>
<div class="field"><h4 id="toiSolver">
<span class="show-code">Code</span>
final <a href="../box2d/TimeOfImpactSolver.html">TimeOfImpactSolver</a>         <strong>toiSolver</strong> <a class="anchor-link"
            href="#toiSolver"
            title="Permalink to World.toiSolver">#</a>
        </h4>
        <div class="doc">

<pre class="source">
final TimeOfImpactSolver toiSolver;
</pre>
</div>
</div>
<div class="field"><h4 id="wqwrapper">
<span class="show-code">Code</span>
final <a href="../box2d/WorldQueryWrapper.html">WorldQueryWrapper</a>         <strong>wqwrapper</strong> <a class="anchor-link"
            href="#wqwrapper"
            title="Permalink to World.wqwrapper">#</a>
        </h4>
        <div class="doc">

<pre class="source">
final WorldQueryWrapper wqwrapper;
</pre>
</div>
</div>
        </div>
        <div class="clear"></div>
        </div>
        
        <div class="footer">
          <div>This page generated at 2012-07-21 17:45:06.798</div>
        </div>
        <script async src="../client-live-nav.js"></script>
        </body></html>
        
