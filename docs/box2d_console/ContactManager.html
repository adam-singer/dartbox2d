        <!DOCTYPE html>
        <html>
        <head>
                <meta charset="utf-8">
        <title>ContactManager class / box2d_console Library / Dart Documentation</title>
        <link rel="stylesheet" type="text/css"
            href="../styles.css">
        <link href="http://fonts.googleapis.com/css?family=Open+Sans:400,600,700,800" rel="stylesheet" type="text/css">
        <link rel="shortcut icon" href="../favicon.ico">
        
        </head>
        <body data-library="box2d_console" data-type="ContactManager">
        <div class="page">
        <div class="header">
          <a href="../index.html"><div class="logo"></div></a>
          <a href="../index.html">Dart Documentation</a>
         &rsaquo; <a href="../box2d_console.html">box2d_console</a> &rsaquo; <a href="../box2d_console/ContactManager.html">ContactManager</a>        <div id="search-box">
          <input type="search" name="q" id="q" autocomplete="off"
              class="search-input" placeholder="Search API">
        </div>
        
      </div>
      <div class="drop-down" id="drop-down"></div>
      
        <div class="nav">
        
</div>
<div class="content">
        <h2><strong>ContactManager</strong>
          class
        </h2>
        
<button id="show-inherited" class="show-inherited">Hide inherited</button>
<div class="doc">
<pre class="source">
class ContactManager implements PairCallback {
  BroadPhase broadPhase;
  Contact contactList;
  int contactCount;
  ContactFilter contactFilter;
  ContactListener contactListener;

  final World pool;

  ContactManager(World argPool) :
    contactList = null,
    contactCount = 0,
    contactFilter = new ContactFilter(),
    contactListener = null,
    broadPhase = new BroadPhase(),
    pool = argPool { }

  /**
   * Broad-phase callback.
   */
  void addPair(Fixture fixtureA, Fixture fixtureB) {
    Body bodyA = fixtureA.body;
    Body bodyB = fixtureB.body;

    // Are the fixtures on the same body?
    if (bodyA === bodyB) {
      return;
    }

    // Does a contact already exist?
    ContactEdge edge = bodyB.contactList;
    while (edge != null) {
      if (edge.other == bodyA) {
        Fixture fA = edge.contact.fixtureA;
        Fixture fB = edge.contact.fixtureB;
        if (fA == fixtureA &amp;&amp; fB == fixtureB) {
          // A contact already exists.
          return;
        }

        if (fA == fixtureB &amp;&amp; fB == fixtureA) {
          // A contact already exists.
          return;
        }
      }

      edge = edge.next;
    }

    // Does a joint override collision? is at least one body dynamic?
    if (bodyB.shouldCollide(bodyA) == false) {
      return;
    }

    // Check user filtering.
    if (contactFilter != null &amp;&amp; 
        contactFilter.shouldCollide(fixtureA, fixtureB) == false) {
      return;
    }

    // Call the factory.
    Contact c = pool.popContact(fixtureA, fixtureB);

    // Contact creation may swap fixtures.
    fixtureA = c.fixtureA;
    fixtureB = c.fixtureB;
    bodyA = fixtureA.body;
    bodyB = fixtureB.body;

    // Insert into the world.
    c.prev = null;
    c.next = contactList;
    if (contactList != null) {
      contactList.prev = c;
    }
    contactList = c;

    // Connect to island graph.

    // Connect to body A
    c.edge1.contact = c;
    c.edge1.other = bodyB;

    c.edge1.prev = null;
    c.edge1.next = bodyA.contactList;
    if (bodyA.contactList != null) {
      bodyA.contactList.prev = c.edge1;
    }
    bodyA.contactList = c.edge1;

    // Connect to body B
    c.edge2.contact = c;
    c.edge2.other = bodyA;

    c.edge2.prev = null;
    c.edge2.next = bodyB.contactList;
    if (bodyB.contactList != null)
      bodyB.contactList.prev = c.edge2;
    bodyB.contactList = c.edge2;

    ++contactCount;
  }

  void findNewContacts() { broadPhase.updatePairs(this); }

  void destroy(Contact c) {
    Fixture fixtureA = c.fixtureA;
    Fixture fixtureB = c.fixtureB;
    Body bodyA = fixtureA.body;
    Body bodyB = fixtureB.body;

    if (contactListener != null &amp;&amp; c.touching) {
      contactListener.endContact(c);
    }

    // Remove from the world.
    if (c.prev != null)
      c.prev.next = c.next;

    if (c.next != null)
      c.next.prev = c.prev;

    if (c == contactList)
      contactList = c.next;

    // Remove from body 1
    if (c.edge1.prev != null)
      c.edge1.prev.next = c.edge1.next;

    if (c.edge1.next != null)
      c.edge1.next.prev = c.edge1.prev;

    if (c.edge1 == bodyA.contactList)
      bodyA.contactList = c.edge1.next;

    // Remove from body 2
    if (c.edge2.prev != null)
      c.edge2.prev.next = c.edge2.next;

    if (c.edge2.next != null)
      c.edge2.next.prev = c.edge2.prev;

    if (c.edge2 == bodyB.contactList)
      bodyB.contactList = c.edge2.next;

    // Call the factory.
    pool.pushContact(c);
    --contactCount;
  }

  /**
   * This is the top level collision call for the time step. Here
   * all the narrow phase collision is processed for the world
   * contact list.
   */
  void collide() {
    // Update awake contacts.
    Contact c = contactList;
    while (c != null) {
      Fixture fixtureA = c.fixtureA;
      Fixture fixtureB = c.fixtureB;
      Body bodyA = fixtureA.body;
      Body bodyB = fixtureB.body;


      if (bodyA.awake == false &amp;&amp; bodyB.awake == false) {
        c = c.next;
        continue;
      }

      // is this contact flagged for filtering?
      if ((c.flags &amp; Contact.FILTER_FLAG) == Contact.FILTER_FLAG) {
        // Should these bodies collide?
        if (bodyB.shouldCollide(bodyA) == false) {
          Contact cNuke = c;
          c = cNuke.next;
          destroy(cNuke);
          continue;
        }

        // Check user filtering.
        if (contactFilter != null &amp;&amp;
            contactFilter.shouldCollide(fixtureA, fixtureB) == false) {
          Contact cNuke = c;
          c = cNuke.next;
          destroy(cNuke);
          continue;
        }

        // Clear the filtering flag.
        c.flags &amp;= ~Contact.FILTER_FLAG;
      }

      DynamicTreeNode proxyIdA = fixtureA.proxy;
      DynamicTreeNode proxyIdB = fixtureB.proxy;

      bool overlap = broadPhase.testOverlap(proxyIdA, proxyIdB);

      // Here we destroy contacts that cease to overlap in the broad-phase.
      if (overlap == false) {
        Contact cNuke = c;
        c = cNuke.next;
        destroy(cNuke);
        continue;
      }

      // The contact persists.
      c.update(contactListener);
      c = c.next;
    }
  }
}
</pre>
</div>
<h3>Implements</h3>
<p>
<span class="type-box"><span class="icon-interface"></span><a href="../box2d_console/PairCallback.html">PairCallback</a></span></p>
<div>
<h3>Constructors</h3>
<div class="method"><h4 id="ContactManager">
<button class="show-code">Code</button>
new <strong>ContactManager</strong>(<a href="../box2d_console/World.html">World</a> argPool) <a class="anchor-link" href="#ContactManager"
              title="Permalink to ContactManager.ContactManager">#</a></h4>
<div class="doc">
<pre class="source">
ContactManager(World argPool) :
  contactList = null,
  contactCount = 0,
  contactFilter = new ContactFilter(),
  contactListener = null,
  broadPhase = new BroadPhase(),
  pool = argPool { }
</pre>
</div>
</div>
</div>
<div>
<h3>Properties</h3>
<div class="field"><h4 id="broadPhase">
<button class="show-code">Code</button>
<a href="../box2d_console/BroadPhase.html">BroadPhase</a>         <strong>broadPhase</strong> <a class="anchor-link"
            href="#broadPhase"
            title="Permalink to ContactManager.broadPhase">#</a>
        </h4>
        <div class="doc">
<pre class="source">
BroadPhase broadPhase;
</pre>
</div>
</div>
<div class="field"><h4 id="contactCount">
<button class="show-code">Code</button>
int         <strong>contactCount</strong> <a class="anchor-link"
            href="#contactCount"
            title="Permalink to ContactManager.contactCount">#</a>
        </h4>
        <div class="doc">
<pre class="source">
int contactCount;
</pre>
</div>
</div>
<div class="field"><h4 id="contactFilter">
<button class="show-code">Code</button>
<a href="../box2d_console/ContactFilter.html">ContactFilter</a>         <strong>contactFilter</strong> <a class="anchor-link"
            href="#contactFilter"
            title="Permalink to ContactManager.contactFilter">#</a>
        </h4>
        <div class="doc">
<pre class="source">
ContactFilter contactFilter;
</pre>
</div>
</div>
<div class="field"><h4 id="contactList">
<button class="show-code">Code</button>
<a href="../box2d_console/Contact.html">Contact</a>         <strong>contactList</strong> <a class="anchor-link"
            href="#contactList"
            title="Permalink to ContactManager.contactList">#</a>
        </h4>
        <div class="doc">
<pre class="source">
Contact contactList;
</pre>
</div>
</div>
<div class="field"><h4 id="contactListener">
<button class="show-code">Code</button>
<a href="../box2d_console/ContactListener.html">ContactListener</a>         <strong>contactListener</strong> <a class="anchor-link"
            href="#contactListener"
            title="Permalink to ContactManager.contactListener">#</a>
        </h4>
        <div class="doc">
<pre class="source">
ContactListener contactListener;
</pre>
</div>
</div>
<div class="field"><h4 id="pool">
<button class="show-code">Code</button>
final <a href="../box2d_console/World.html">World</a>         <strong>pool</strong> <a class="anchor-link"
            href="#pool"
            title="Permalink to ContactManager.pool">#</a>
        </h4>
        <div class="doc">
<pre class="source">
final World pool;
</pre>
</div>
</div>
<div class="field inherited"><h4 id="runtimeType">
<button class="show-code">Code</button>
final Type         <strong>runtimeType</strong> <a class="anchor-link"
            href="#runtimeType"
            title="Permalink to ContactManager.runtimeType">#</a>
        </h4>
        <div class="inherited-from">inherited from Object </div><div class="doc">
<p>A representation of the runtime type of the object.</p>
<pre class="source">
external Type get runtimeType;
</pre>
</div>
</div>
</div>
<div>
<h3>Operators</h3>
<div class="method inherited"><h4 id="==">
<button class="show-code">Code</button>
bool <strong>operator ==</strong>(other) <a class="anchor-link" href="#=="
              title="Permalink to ContactManager.operator ==">#</a></h4>
<div class="inherited-from">inherited from Object </div><div class="doc">
<p>The equality operator.</p>
<p>The default behavior for all <code>Object</code>s is to return true if and
only if <code>this</code> and 
<span class="param">other</span> are the same object.</p>
<p>If a subclass overrides the equality operator it should override
the <code>hashCode</code> method as well to maintain consistency.</p>
<pre class="source">
bool operator ==(other) =&gt; identical(this, other);
</pre>
</div>
</div>
</div>
<div>
<h3>Methods</h3>
<div class="method"><h4 id="addPair">
<button class="show-code">Code</button>
void <strong>addPair</strong>(<a href="../box2d_console/Fixture.html">Fixture</a> fixtureA, <a href="../box2d_console/Fixture.html">Fixture</a> fixtureB) <a class="anchor-link" href="#addPair"
              title="Permalink to ContactManager.addPair">#</a></h4>
<div class="doc">
<p>Broad-phase callback.</p>
<pre class="source">
void addPair(Fixture fixtureA, Fixture fixtureB) {
  Body bodyA = fixtureA.body;
  Body bodyB = fixtureB.body;

  // Are the fixtures on the same body?
  if (bodyA === bodyB) {
    return;
  }

  // Does a contact already exist?
  ContactEdge edge = bodyB.contactList;
  while (edge != null) {
    if (edge.other == bodyA) {
      Fixture fA = edge.contact.fixtureA;
      Fixture fB = edge.contact.fixtureB;
      if (fA == fixtureA &amp;&amp; fB == fixtureB) {
        // A contact already exists.
        return;
      }

      if (fA == fixtureB &amp;&amp; fB == fixtureA) {
        // A contact already exists.
        return;
      }
    }

    edge = edge.next;
  }

  // Does a joint override collision? is at least one body dynamic?
  if (bodyB.shouldCollide(bodyA) == false) {
    return;
  }

  // Check user filtering.
  if (contactFilter != null &amp;&amp; 
      contactFilter.shouldCollide(fixtureA, fixtureB) == false) {
    return;
  }

  // Call the factory.
  Contact c = pool.popContact(fixtureA, fixtureB);

  // Contact creation may swap fixtures.
  fixtureA = c.fixtureA;
  fixtureB = c.fixtureB;
  bodyA = fixtureA.body;
  bodyB = fixtureB.body;

  // Insert into the world.
  c.prev = null;
  c.next = contactList;
  if (contactList != null) {
    contactList.prev = c;
  }
  contactList = c;

  // Connect to island graph.

  // Connect to body A
  c.edge1.contact = c;
  c.edge1.other = bodyB;

  c.edge1.prev = null;
  c.edge1.next = bodyA.contactList;
  if (bodyA.contactList != null) {
    bodyA.contactList.prev = c.edge1;
  }
  bodyA.contactList = c.edge1;

  // Connect to body B
  c.edge2.contact = c;
  c.edge2.other = bodyA;

  c.edge2.prev = null;
  c.edge2.next = bodyB.contactList;
  if (bodyB.contactList != null)
    bodyB.contactList.prev = c.edge2;
  bodyB.contactList = c.edge2;

  ++contactCount;
}
</pre>
</div>
</div>
<div class="method"><h4 id="collide">
<button class="show-code">Code</button>
void <strong>collide</strong>() <a class="anchor-link" href="#collide"
              title="Permalink to ContactManager.collide">#</a></h4>
<div class="doc">
<p>This is the top level collision call for the time step. Here
all the narrow phase collision is processed for the world
contact list.</p>
<pre class="source">
void collide() {
  // Update awake contacts.
  Contact c = contactList;
  while (c != null) {
    Fixture fixtureA = c.fixtureA;
    Fixture fixtureB = c.fixtureB;
    Body bodyA = fixtureA.body;
    Body bodyB = fixtureB.body;


    if (bodyA.awake == false &amp;&amp; bodyB.awake == false) {
      c = c.next;
      continue;
    }

    // is this contact flagged for filtering?
    if ((c.flags &amp; Contact.FILTER_FLAG) == Contact.FILTER_FLAG) {
      // Should these bodies collide?
      if (bodyB.shouldCollide(bodyA) == false) {
        Contact cNuke = c;
        c = cNuke.next;
        destroy(cNuke);
        continue;
      }

      // Check user filtering.
      if (contactFilter != null &amp;&amp;
          contactFilter.shouldCollide(fixtureA, fixtureB) == false) {
        Contact cNuke = c;
        c = cNuke.next;
        destroy(cNuke);
        continue;
      }

      // Clear the filtering flag.
      c.flags &amp;= ~Contact.FILTER_FLAG;
    }

    DynamicTreeNode proxyIdA = fixtureA.proxy;
    DynamicTreeNode proxyIdB = fixtureB.proxy;

    bool overlap = broadPhase.testOverlap(proxyIdA, proxyIdB);

    // Here we destroy contacts that cease to overlap in the broad-phase.
    if (overlap == false) {
      Contact cNuke = c;
      c = cNuke.next;
      destroy(cNuke);
      continue;
    }

    // The contact persists.
    c.update(contactListener);
    c = c.next;
  }
}
</pre>
</div>
</div>
<div class="method"><h4 id="ContactManager">
<button class="show-code">Code</button>
new <strong>ContactManager</strong>(<a href="../box2d_console/World.html">World</a> argPool) <a class="anchor-link" href="#ContactManager"
              title="Permalink to ContactManager.ContactManager">#</a></h4>
<div class="doc">
<pre class="source">
ContactManager(World argPool) :
  contactList = null,
  contactCount = 0,
  contactFilter = new ContactFilter(),
  contactListener = null,
  broadPhase = new BroadPhase(),
  pool = argPool { }
</pre>
</div>
</div>
<div class="method"><h4 id="destroy">
<button class="show-code">Code</button>
void <strong>destroy</strong>(<a href="../box2d_console/Contact.html">Contact</a> c) <a class="anchor-link" href="#destroy"
              title="Permalink to ContactManager.destroy">#</a></h4>
<div class="doc">
<pre class="source">
void destroy(Contact c) {
  Fixture fixtureA = c.fixtureA;
  Fixture fixtureB = c.fixtureB;
  Body bodyA = fixtureA.body;
  Body bodyB = fixtureB.body;

  if (contactListener != null &amp;&amp; c.touching) {
    contactListener.endContact(c);
  }

  // Remove from the world.
  if (c.prev != null)
    c.prev.next = c.next;

  if (c.next != null)
    c.next.prev = c.prev;

  if (c == contactList)
    contactList = c.next;

  // Remove from body 1
  if (c.edge1.prev != null)
    c.edge1.prev.next = c.edge1.next;

  if (c.edge1.next != null)
    c.edge1.next.prev = c.edge1.prev;

  if (c.edge1 == bodyA.contactList)
    bodyA.contactList = c.edge1.next;

  // Remove from body 2
  if (c.edge2.prev != null)
    c.edge2.prev.next = c.edge2.next;

  if (c.edge2.next != null)
    c.edge2.next.prev = c.edge2.prev;

  if (c.edge2 == bodyB.contactList)
    bodyB.contactList = c.edge2.next;

  // Call the factory.
  pool.pushContact(c);
  --contactCount;
}
</pre>
</div>
</div>
<div class="method"><h4 id="findNewContacts">
<button class="show-code">Code</button>
void <strong>findNewContacts</strong>() <a class="anchor-link" href="#findNewContacts"
              title="Permalink to ContactManager.findNewContacts">#</a></h4>
<div class="doc">
<pre class="source">
void findNewContacts() { broadPhase.updatePairs(this); }
</pre>
</div>
</div>
<div class="method inherited"><h4 id="hashCode">
<button class="show-code">Code</button>
int <strong>hashCode</strong>() <a class="anchor-link" href="#hashCode"
              title="Permalink to ContactManager.hashCode">#</a></h4>
<div class="inherited-from">inherited from Object </div><div class="doc">
<p>Get a hash code for this object.</p>
<p>All objects have hash codes. Hash codes are guaranteed to be the
same for objects that are equal when compared using the equality
operator <code>==</code>. Other than that there are no guarantees about
the hash codes. They will not be consistent between runs and
there are no distribution guarantees.</p>
<p>If a subclass overrides <code>hashCode</code> it should override the
equality operator as well to maintain consistency.</p>
<pre class="source">
external int hashCode();
</pre>
</div>
</div>
<div class="method inherited"><h4 id="noSuchMethod">
<button class="show-code">Code</button>
<strong>noSuchMethod</strong>(String name, List args) <a class="anchor-link" href="#noSuchMethod"
              title="Permalink to ContactManager.noSuchMethod">#</a></h4>
<div class="inherited-from">inherited from Object </div><div class="doc">
<p><code>noSuchMethod</code> is invoked when users invoke a non-existant method
on an object. The name of the method and the arguments of the
invocation are passed to <code>noSuchMethod</code>. If <code>noSuchMethod</code>
returns a value, that value becomes the result of the original
invocation.</p>
<p>The default behavior of <code>noSuchMethod</code> is to throw a
<code>noSuchMethodError</code>.</p>
<pre class="source">
external Dynamic noSuchMethod(String name, List args);
</pre>
</div>
</div>
<div class="method inherited"><h4 id="Object">
<button class="show-code">Code</button>
const <strong>Object</strong>() <a class="anchor-link" href="#Object"
              title="Permalink to ContactManager.Object">#</a></h4>
<div class="inherited-from">inherited from Object </div><div class="doc">
<p>Creates a new <code>Object</code> instance.</p>
<p><code>Object</code> instances have no meaningful state, and are only useful
through their identity. An <code>Object</code> instance is equal to itself
only.</p>
<pre class="source">
const Object();
</pre>
</div>
</div>
<div class="method inherited"><h4 id="toString">
<button class="show-code">Code</button>
String <strong>toString</strong>() <a class="anchor-link" href="#toString"
              title="Permalink to ContactManager.toString">#</a></h4>
<div class="inherited-from">inherited from Object </div><div class="doc">
<p>Returns a string representation of this object.</p>
<pre class="source">
external String toString();
</pre>
</div>
</div>
</div>
        </div>
        <div class="clear"></div>
        </div>
        
        <div class="footer">
          
        </div>
        <script async src="../client-live-nav.js"></script>
        </body></html>
        
